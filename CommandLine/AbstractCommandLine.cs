using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;

namespace CommandLine {

    /**
     * Defines an abstract base class for all CommandLine implementations. The basic 
     * usage pattern is:
     * 1) Create a new class derived from AbstractCommandLine, i.e. MyAppCommandLine.
     * 2) Add properties to MyAppCommandLine, marked with the CommandLineOption attribute.
     * 3) At run-time, feed the Main() args string array to the constructor of MyAppCommandLine.
     *    This will bind the command line options to the derived class properties.
     * 4) Access the properties of MyAppCommandLine to determine how your application should 
     *    behave.
     *    
     * Using this approach saves you the effort of having to parse the string args array passed into 
     * Main(), and makes changes or updates to the command line arg list easy to implement.
     * 
     * Note that the "-?" command line option is used for printing usage. Usage text can be 
     * automatically generated by calling MyAppCommandLine.PrintUsage(), for example.
     * 
     * Derived classes can also specify additional pre- and post-usage text, in case additional
     * information needs to be presented when usage is printed.
     * 
     * Arguments that are required but missing are accessed through the MissingCommandLine 
     * property. Note that no exception is thrown when a command line is incomplete. Consult the
     * MissingCommandLine list to verify everything worked properly.
     * 
     * Note that multiple flag options are no allowed. For example, in Unix you might type "rm -rf"
     * which conveys two flags in one argument ("r" and "f"). CommandLine expect multiple 
     * flags to have their own argument (e.g. "rm -r -f").
     */
    public abstract class AbstractCommandLine {

        [CommandLineOption("Prints usage information.", false, '?', "help")]
        public bool DoPrintUsage { get; set; }

        protected IList<CommandLineOption> missingRequiredCommandLineOptions;
        /**
         * A list of all required command line options that were not supplied.
         */
        public IList<CommandLineOption> MissingRequiredCommandLineOptions { get { return this.missingRequiredCommandLineOptions; } }

        public bool HasMissingRequiredCommandLineOptions { get { return this.missingRequiredCommandLineOptions.Count > 0; } }

        // Bookkeeping -- A list of all CommandLine discovered on the derived class
        protected List<CommandLineOption> allOptions;

        // Bookkeeping -- A list of all CommandLine discovered on the derived class
        protected List<CommandLineOption> requiredOptions;

        // Bookkeeping -- A list of all CommandLine discovered on the derived class
        protected List<CommandLineOption> optionalOptions;

        // Bookkeeping -- A map of CommandLine to the properties they are attached to
        protected Dictionary<CommandLineOption, PropertyInfo> optionPropertyDict;

        // Bookkeeping -- A map of all incoming argument keys to argument values.
        protected Dictionary<string, string> argValDict;

        // Bookkeeping -- The singular CommandLineOption that represents the command line target, if any.
        protected CommandLineOption targetCommandLineOption;

        // Bookkeeping -- The singular target value
        protected string targetValue;

        // Bookkeeping -- The last arg key in the command line, if any (used for bool/target mediation)
        protected string lastArgKey;

        // Bookkeeping -- The last arg value in the command line, if any (used for bool/target mediation)
        protected string lastArgValue;

        /**
         * Accepts command line args in the form of a string array, and assigns the 
         * given values to the object properties annotated by CommandLineOption attributes.
         * Any text output (e.g. usage, errors) is written to Console.Out.
         */
        protected AbstractCommandLine(String[] args) 
        : this(args, Console.Out) 
        {}

        /**
         * Accepts command line args in the form of a string array, and assigns the 
         * given values to the object properties annotated by CommandLineOption attributes.
         * Any text output (e.g. usage, errors) is written to the given TextWriter.
         */
        protected AbstractCommandLine(String[] args, TextWriter writer) {
            this.allOptions = new List<CommandLineOption>();
            this.requiredOptions = new List<CommandLineOption>();
            this.optionalOptions = new List<CommandLineOption>();
            this.optionPropertyDict = new Dictionary<CommandLineOption, PropertyInfo>();
            this.argValDict = new Dictionary<string, string>();
            this.targetCommandLineOption = null;
            this.targetValue = null;
            this.lastArgKey = null;
            this.lastArgValue = null;
            this.missingRequiredCommandLineOptions = new List<CommandLineOption>();
            this.ProcessOptions(args, writer);
        }

        /**
         * The master processing method.
         */
        protected void ProcessOptions(String[] args, TextWriter writer) {

            // Collect all CommandLine from the derived class, then initialize them
            this.InitializeCommandLineOptions();

            // Collect arguments from the command line
            this.InitializeCommandLineArgs(args);

            // Now assign the values
            this.AssignCommandLineOptionValues();

            // Print the usage if requested
            if (this.DoPrintUsage) {
                this.PrintUsage(writer);
            }

            // Print missing required arguments, if any
            else if (this.missingRequiredCommandLineOptions.Count > 0) {
                this.PrintMissing(writer);
            }

            // That's it.
        }

        /**
         * As part of processing a command line, this method scans the (derived) class for all
         * CommandLineOption propertiess.
         */
        protected void InitializeCommandLineOptions() {
            PropertyInfo[] properties = this.GetAllProperties(this.GetType());
            foreach (PropertyInfo property in properties) {
                CommandLineOption commandLineOption = (CommandLineOption)this.GetPropertyAttribute(property, typeof(CommandLineOption));
                if (commandLineOption != null) {

                    // Remember the property so we can assign the value later.
                    this.optionPropertyDict[commandLineOption] = property;

                    // Capture the option
                    this.allOptions.Add(commandLineOption);

                    // Is it optional?
                    if (!commandLineOption.IsTargetOption) {
                        if (commandLineOption.IsRequired) {
                            this.requiredOptions.Add(commandLineOption);
                        }
                        else {
                            this.optionalOptions.Add(commandLineOption);
                        }
                    }

                    // Make special note of the target option, if any
                    if (commandLineOption.IsTargetOption) {
                        if (this.targetCommandLineOption != null) {
                            throw new CommandLineException("Too many target command line options. One is maximum.");
                        }
                        else {
                            this.targetCommandLineOption = commandLineOption;
                        }
                    }
                }
            }

            // Move the target command line option to the end so it's considered last
            if (this.targetCommandLineOption != null) {
                this.allOptions.Remove(this.targetCommandLineOption);
                this.allOptions.Add(this.targetCommandLineOption);
            }
        }

        /**
         * This method converts the incoming command line args into a Dictionary of
         * keys of values. This does not actually assign the property values; it just collects
         * the string args into an indexed form for further processing.
         */
        protected void InitializeCommandLineArgs(string[] args) {
            // Rebuild the command line
            string commandLine = this.RebuildCommandLine(args);

            // Match to the regex
            Regex regex = new Regex(this.CommandLineRegex);
            MatchCollection matches = regex.Matches(commandLine);

            // Collect all the arguments and their values (if any)
            foreach (Match match in matches) {

                // Process target option
                if (match.Groups["TargetValue"].Captures.Count > 0) {
                    targetValue = match.Groups["TargetValue"].Captures[0].Value;
                }

                // Process keyed options
                for (int i = 0; i < match.Groups["Arg"].Captures.Count; i++) {
                    string argSymbol = match.Groups["ArgSymbol"].Captures[0].Value;
                    string argValue = null;
                    if (match.Groups["ArgValue"].Captures.Count > 0) {
                        argValue = match.Groups["ArgValue"].Captures[0].Value;
                    }
                    argValDict[argSymbol] = argValue;
                    this.lastArgKey = argSymbol;
                    this.lastArgValue = argValue;
                }
            }
        }

        /**
         * The final step in command line processing, this method will assign the incoming, indexed string arg
         * values to the CommandLineOption properties. A few notes:
         * 
         * Boolean flags are either present or not. If present, they are assigned true. If missing, they are assigned false.
         * 
         * Keyed values expect a value to follow immediately.
         * 
         * Target values always appear last in the command line. There may be only one.
         * 
         * There is a case handled here where a command line contains a target value with a boolean flag
         * immediately preceding it. In this case, the regex accepts the target as the value of the boolean 
         * flag, which is incorrect. So, there's logic here to tease out the value from the boolean keyed
         * value and treat it as the target. Whew.
         */
        protected void AssignCommandLineOptionValues() {
            foreach (CommandLineOption commandLineOption in this.allOptions) {
                PropertyInfo property = this.optionPropertyDict[commandLineOption];

                // Is this a bool property? If so, its value is true if the arg is present, false if not.
                if (property.PropertyType == typeof(bool)) {
                    property.SetValue(this, this.IsCommandLineOptionPresent(commandLineOption), null);
                }

                // Otherwise it's a target or keyed value.
                else {

                    bool valueAssigned = false;

                    // Is this the target option?
                    if (commandLineOption.IsTargetOption) {
                        // Assign the target value if we have one
                        if (this.targetValue != null) {
                            this.AssignPropertyValue(property, this.targetValue);
                            valueAssigned = true;
                        }
                        // Target value not set; check the last keyed arg. If bool, the option's value is actually the target.
                        // If the last arg is NOT a bool, then it's a legit keyed argument and the target is just missing.
                        else if (this.lastArgKey != null) {
                            CommandLineOption lastCommandLineOption = this.FindCommandLineOption(lastArgKey);
                            if (
                                lastCommandLineOption != null &&
                                this.optionPropertyDict[lastCommandLineOption].PropertyType == typeof(bool) && 
                                lastArgValue != null
                            ) {
                                this.AssignPropertyValue(property, lastArgValue);
                                valueAssigned = true;
                            }
                        }
                    }

                    // If it's a keyed option and it's present, assign it.
                    else if (this.IsCommandLineOptionPresent(commandLineOption)) {
                        string value = this.GetCommandLineOptionValue(commandLineOption);
                        this.AssignPropertyValue(property, value);
                        valueAssigned = true;
                    }

                    // A value wasn't assigned (either target or keyed). Deal with required/default values.
                    if (!valueAssigned) {

                        // Gather missing required args
                        if (commandLineOption.IsRequired) {
                            this.missingRequiredCommandLineOptions.Add(commandLineOption);
                        }

                        // Otherwise it's optional, so set the default value
                        else {
                            this.AssignPropertyValue(property, commandLineOption.DefaultValue);
                        }
                    }
                }
            }
        }

        /**
         * Finds a CommandLineOption on this class that matches the given symbol (short or long).
         * Returns null if no such CommandLineOption exists.
         */
        protected CommandLineOption FindCommandLineOption(string symbol) {
            CommandLineOption commandLineOption = null;
            foreach (CommandLineOption o in this.allOptions) {
                if (lastArgKey.Equals("" + o.ShortSymbol) || lastArgKey.Equals(o.LongSymbol)) {
                    commandLineOption = o;
                    break;
                }
            }
            return commandLineOption;
        }

        /**
         * Transforms a command line expressed as an array of strings (i.e. what Main() accepts as an
         * argument) into a space-delimited string suitable for regex matching.
         */
        protected string RebuildCommandLine(string[] args) {
            string commandLine = "";
            foreach (string arg in args) {
                string a = arg.Trim();
                if (a.StartsWith("-")) {
                    commandLine += a;
                }
                else {
                    commandLine += "\"" + arg + "\"";
                }
                commandLine += " ";
            }
            return commandLine;
        }

        /**
         * Produces the command line regex pattern string. Expressed here in this way mainly for
         * readability and ease of editing.
         */
        protected string CommandLineRegex {
            get {
                // Compose the regex. Concatenated together only for readability.
                string valueSymbols =       "[a-zA-Z0-9`~!@#$%^&*()_+=\\{}|\\:;<>,.?/-]";
                string valueSymbolsNoDash = "[a-zA-Z0-9`~!@#$%^&*()_+=\\{}|\\:;<>,.?/]";
                String pattern = "";
                pattern += "\\s*(?<AllArgs>";
                    pattern += "(?<Arg>";
                        pattern += "-(?<ArgSymbol>[a-zA-Z0-9?]+)";
                        pattern += "(?<ArgValuesGroup>";
                            pattern += "(";
                                pattern += "\\s+\"(?<ArgValue>" + valueSymbols + "*)\"";
                                pattern += "|";
                                pattern += "\\s+(?<ArgValue>" + valueSymbolsNoDash + "{1}" + valueSymbols + "*)";
                            pattern += "){0,1}";
                        pattern += ")";
                    pattern += ")*";
                pattern += ")";
                pattern += "(?<TargetValueGroup>";
                    pattern += "\\s*\"(?<TargetValue>" + valueSymbols + "+)\"";
                    pattern += "|";
                    pattern += "\\s*(?<TargetValue>" + valueSymbolsNoDash + "{1}" + valueSymbols + "*)";
                pattern += "){0,1}";
                //\s*(?<AllArgs>(?<Arg>-(?<ArgSymbol>[a-zA-Z0-9?]+)(?<ArgValuesGroup>(\s+"(?<ArgValue>[a-zA-Z0-9`~!@#$%^&*()_+=\{}|\:;<>,.?/-]*)"|\s+(?<ArgValue>[a-zA-Z0-9`~!@#$%^&*()_+=\{}|\:;<>,.?/]{1}[a-zA-Z0-9`~!@#$%^&*()_+=\{}|\:;<>,.?/-]*)){0,1}))*)(?<TargetValueGroup>\s*"(?<TargetValue>[a-zA-Z0-9`~!@#$%^&*()_+=\{}|\:;<>,.?/-]+)"|\s*(?<TargetValue>[a-zA-Z0-9`~!@#$%^&*()_+=\{}|\:;<>,.?/]{1}[a-zA-Z0-9`~!@#$%^&*()_+=\{}|\:;<>,.?/-]*)){0,1}
                return pattern;
            }
        }

        /**
         * Returns true if the given CommandLineOption was present on the actual command line.
         * We need this in addition to GetCommandLineOptionValue() because it returns null
         * for bool values, which is correct; this method, on the other hand, just checks for 
         * keys.
         */
        protected bool IsCommandLineOptionPresent(CommandLineOption commandLineOption) {
            bool present = false;
            // Is it the target?
            if (commandLineOption.IsTargetOption) {
                present = this.targetValue != null;
            }
            // If not the target, then it may have been provided as a keyed argument.
            // Check for both long and short symbols.
            else {
                present =
                    this.argValDict.ContainsKey(commandLineOption.ShortSymbol.ToString())
                    ||
                    this.argValDict.ContainsKey(commandLineOption.LongSymbol);
            }
            return present;
        }

        /**
         * Checks the provided command line values for both long and short symbol versions
         * of the given CommandLineOption.
         */
        protected string GetCommandLineOptionValue(CommandLineOption commandLineOption) {
            string value = null;
            if (commandLineOption.IsTargetOption) {
                value = this.targetValue;
            }
            else if (this.argValDict.ContainsKey(commandLineOption.ShortSymbol.ToString())) {
                value = this.argValDict[commandLineOption.ShortSymbol.ToString()];
            }
            else if (this.argValDict.ContainsKey(commandLineOption.LongSymbol)) {
                value = this.argValDict[commandLineOption.LongSymbol];
            }
            return value;
        }

        /**
         * Assigns an actual command line value to the property associated with the CommandLineOption.
         */
        protected void AssignPropertyValue(PropertyInfo property, string value) {
            Type propertyType = property.PropertyType;
            if (propertyType == typeof(byte)) {
                property.SetValue(this, byte.Parse(value), null);
            }
            else if (propertyType == typeof(short)) {
                property.SetValue(this, short.Parse(value), null);
            }
            else if (propertyType == typeof(int)) {
                property.SetValue(this, int.Parse(value), null);
            }
            else if (propertyType == typeof(long)) {
                property.SetValue(this, long.Parse(value), null);
            }
            else  if (propertyType == typeof(ushort)) {
                property.SetValue(this, ushort.Parse(value), null);
            }
            else if (propertyType == typeof(uint)) {
                property.SetValue(this, uint.Parse(value), null);
            }
            else if (propertyType == typeof(ulong)) {
                property.SetValue(this, ulong.Parse(value), null);
            }
            else if (propertyType == typeof(float)) {
                property.SetValue(this, float.Parse(value), null);
            }
            else if (propertyType == typeof(double)) {
                property.SetValue(this, double.Parse(value), null);
            }
            else if (propertyType == typeof(bool)) {
                property.SetValue(this, short.Parse(value), null);
            }
            else if (propertyType == typeof(string)) {
                property.SetValue(this, value, null);
            }
            else {
                throw new CommandLineException("\""+propertyType.Name+"\" is not a supported property type.");
            }
        }

        /**
         * Checks the given property to see if it is annotated by an attribute of the given type,
         * and returns that Attribute if so. If not, this returns null.
         */
        protected Attribute GetPropertyAttribute(PropertyInfo property, Type attributeType) {
            Attribute result = null;
            object[] attributes = property.GetCustomAttributes(attributeType, true);
            foreach (object a in attributes) {
                Attribute attribute = (Attribute)a;
                if (attributeType.IsInstanceOfType(attribute)) {
                    result = attribute;
                    break;
                }
            }
            return result;
        }

        // Fetches all properties from the hierarchy
        protected PropertyInfo[] GetAllProperties(Type type) {
            List<PropertyInfo> result = new List<PropertyInfo>();

            // Climb the type hierarchy
            Type temp = type;
            while (temp != null) {
            
                // Get the properties for this level of the hierarchy
                PropertyInfo[] properties = temp.GetProperties(
                    BindingFlags.Instance |
                    BindingFlags.Public |
                    BindingFlags.NonPublic
                );
                
                // Insert the properties in order, by type
                foreach (PropertyInfo property in properties) {
                    result.Add(property);
                }
                // Up we go
                temp = temp.BaseType;
            }
            return result.ToArray();
        }

        /**
         * Creates a usage message from the information contained in all CommandLineOption
         * attributes and prints it to Console.Out.
         */
        public void PrintUsage() {
            this.PrintUsage(Console.Out);
        }

        /**
         * Creates a usage message from the information contained in all CommandLineOption
         * attributes and prints it to the given TextWriter.
         */
        public void PrintUsage(TextWriter writer) {

            object[] attrs = this.GetType().GetCustomAttributes(typeof(CommandLineUsage), true);
            CommandLineUsage commandLine = null;
            if (attrs != null && attrs.Length > 0) {
                commandLine = (CommandLineUsage)attrs[0];
            }

            List<CommandLineOption> options = this.allOptions;
            options.Sort();
            if (commandLine != null && commandLine.PreUsageMessage != null) {
                writer.WriteLine(commandLine.PreUsageMessage);
            }

            if (commandLine != null && commandLine.ExecutableName != null) {
                writer.WriteLine("Usage:");
                writer.Write("  " + commandLine.ExecutableName);
                if (this.optionalOptions.Count + this.optionalOptions.Count  > 0) {
                    writer.Write(" [options]");
                }
                if (this.targetCommandLineOption != null) {
                    writer.Write(" (" + this.targetCommandLineOption.Description + ")");
                }
                writer.Write("\n");
            }

            int maxLongSymbolLength = 0;
            foreach (CommandLineOption option in options) {
                if (option.LongSymbol != null) {
                    maxLongSymbolLength = System.Math.Max(maxLongSymbolLength, option.LongSymbol.Length);
                }
            }
            string nonTargetFormat = "  -{0}, -{1,-" + maxLongSymbolLength +     "}   {2}   {3}{4}";
            string targetFormat = "  [target]".PadRight(maxLongSymbolLength + 10) +  "{2}   {3}{4}";

            SortedDictionary<char, string> sorted = new SortedDictionary<char, string>();

            writer.WriteLine("Options:");
            if (this.targetCommandLineOption != null) {
                writer.WriteLine(this.FormatOption(targetFormat, this.targetCommandLineOption));
            }
            foreach (CommandLineOption option in options) {
                if (option != this.targetCommandLineOption) {
                    sorted[option.ShortSymbol] = this.FormatOption(nonTargetFormat, option);
                }
            }
            foreach (char c in sorted.Keys) {
                writer.WriteLine(sorted[c]);
            }

            if (commandLine != null && commandLine.PostUsageMessage != null) {
                writer.WriteLine(commandLine.PostUsageMessage);
            }
        }

        private string FormatOption(string format, CommandLineOption option) {
            return String.Format(
                format,
                option.ShortSymbol,
                option.LongSymbol,
                option.IsRequired ? "required" : "optional",
                option.Description,
                option.DefaultValue != null ? " (\"" + option.DefaultValue + "\")" : ""
            );
        }

        /**
         * Creates a message describing the required properties that are missing, if any, and 
         * prints it to Console.Out.
         */
        public void PrintMissing() {
            this.PrintMissing(Console.Out);
        }

        /**
         * Creates a message describing the required properties that are missing, if any, and 
         * prints it to the given TextWriter.
         */
        public void PrintMissing(TextWriter writer) {
            if (this.missingRequiredCommandLineOptions.Count > 0) {
                writer.WriteLine("***");
                writer.WriteLine("*** Missing required command line options!");
                writer.WriteLine("***");
                this.PrintUsage(writer);
            }
        }
    }
}